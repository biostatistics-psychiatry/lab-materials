{
  "hash": "b0493eed87a5a58e4d5ec1d343c1af00",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Lab: Tidy Data Manipulation\"\nnumber-sections: true\nformat: live-html\nengine: knitr\nwebr:\n  packages:\n    - dplyr\n    - tidyr\n    - readr\n    - ggplot2\nresources:\n  - ../data/steps_clean.csv\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell edit='false'}\n```{webr}\n#| edit: false\n#| output: false\nwebr::install(\"gradethis\", quiet = TRUE)\nlibrary(gradethis)\noptions(webr.exercise.checker = function(\n  label, user_code, solution_code, check_code, envir_result, evaluate_result,\n  envir_prep, last_value, engine, stage, ...\n) {\n  if (is.null(check_code)) {\n    # No grading code, so just skip grading\n    invisible(NULL)\n  } else if (is.null(label)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = \"All exercises must have a label.\"\n    )\n  } else if (is.null(solution_code)) {\n    list(\n      correct = FALSE,\n      type = \"warning\",\n      message = htmltools::tags$div(\n        htmltools::tags$p(\"A problem occurred grading this exercise.\"),\n        htmltools::tags$p(\n          \"No solution code was found. Note that grading exercises using the \",\n          htmltools::tags$code(\"gradethis\"),\n          \"package requires a model solution to be included in the document.\"\n        )\n      )\n    )\n  } else {\n    gradethis::gradethis_exercise_checker(\n      label = label, solution_code = solution_code, user_code = user_code,\n      check_code = check_code, envir_result = envir_result,\n      evaluate_result = evaluate_result, envir_prep = envir_prep,\n      last_value = last_value, stage = stage, engine = engine)\n  }\n})\n```\n:::\n\n\n\nIn this lab, you'll practice data manipulation skills using the [tidyverse](https://www.tidyverse.org/). We'll work with the [STePS dataset](https://github.com/rpsychologist/STePS-study/blob/main/data/steps.csv) to practice selecting, filtering, creating new variables, summarizing, and reshaping data.\n\n::: {.callout-tip}\nWhile you can complete all the exercises in your browser, we recommend also practicing in RStudio. Using an editor like RStudio will help you build real-world skills for writing, running, and saving your R code.\n:::\n\n# Load the data {.unnumbered}\n\nFirst, let's load the packages and data. \n\n\n::: {.cell setup='true' exercise='[\"ex_1\",\"ex_2\",\"ex_3\",\"ex_4\",\"ex_5\",\"ex_6\",\"ex_7\",\"ex_8\",\"ex_9\",\"ex_10\",\"ex_11\",\"ex_12\",\"ex_13\",\"ex_14\"]'}\n```{webr}\n#| label: setup\n#| setup: true\n#| exercise:\n#|  - ex_1\n#|  - ex_2\n#|  - ex_3\n#|  - ex_4\n#|  - ex_5\n#|  - ex_6\n#|  - ex_7\n#|  - ex_8\n#|  - ex_9\n#|  - ex_10\n#|  - ex_11\n#|  - ex_12\n#|  - ex_13\n#|  - ex_14\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(readr)\nlibrary(ggplot2)\n\n# Load the data\ndf_clean <- read_csv(\"data/steps_clean.csv\")\n\n# Quick check\nglimpse(df_clean)\n```\n:::\n\n\n\n::: {.cell}\n```{webr}\n#| label: setup-session\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(readr)\n\n# Load the data\ndf_clean <- read_csv(\"data/steps_clean.csv\")\n\n# Quick check\nglimpse(df_clean)\n```\n:::\n\n\n# Selecting columns with `select()`\n\nThe `select()` function lets you choose which columns to keep in your dataset.\n\n::: {#exr-select-basic}\n## Select specific columns\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nSelect only the `id`, `group`, and baseline LSAS score (`lsas_screen`) from the dataset.\n\n\n::: {.cell exercise='ex_1'}\n```{webr}\n#| label: ex-1\n#| exercise: ex_1\n\n# Select specific columns\ndf_selected <- df_clean |>\n  select(______, ______, ______)\n\n# Check the result\nhead(df_selected)\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_1\"}\n\nThe `select()` function takes column names separated by commas. You don't need quotes around the column names.\n\nThink about which three columns you need: the participant identifier, their treatment assignment, and their baseline LSAS score.\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_1\"}\n\n\n::: {.cell exercise='ex_1' solution='true'}\n```{webr}\n#| label: ex-1-solution\n#| exercise: ex_1\n#| solution: true\n\n# Select specific columns\ndf_selected <- df_clean |>\n  select(id, trt, lsas_screen) #<1>\n\n# Check the result\nhead(df_selected)\n```\n:::\n\n1. Select just these three columns from the dataset\n\n:::\n\n\n::: {.cell exercise='ex_1' check='true'}\n```{webr}\n#| label: ex-1-gradethis\n#| exercise: ex_1\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n::: {#exr-select-helpers}\n## Use select helpers to grab multiple columns\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nSelect the `id`, `trt`, and all columns that start with \"phq9\" using the `starts_with()` helper function.\n\n\n::: {.cell exercise='ex_2'}\n```{webr}\n#| label: ex-2\n#| exercise: ex_2\n\n# Select using helper functions\ndf_phq9 <- df_clean |>\n  select(id, trt, ______)\n\n# How many columns?\nncol(df_phq9)\nnames(df_phq9)\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_2\"}\n\nHelper functions like `starts_with()` need a character string (text in quotes) as their argument.\n\nLook at the column names in the problem - what pattern do all the PHQ-9 columns share? What text do they all start with?\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_2\"}\n\n\n::: {.cell exercise='ex_2' solution='true'}\n```{webr}\n#| label: ex-2-solution\n#| exercise: ex_2\n#| solution: true\n\n# Select using helper functions\ndf_phq9 <- df_clean |>\n  select(id, trt, starts_with(\"phq9\")) #<1>\n\n# How many columns?\nncol(df_phq9)\nnames(df_phq9)\n```\n:::\n\n1. `starts_with()` selects all columns beginning with \"phq9\"\n\nYou should have 6 columns total: id, trt, and 4 PHQ-9 measurements (screen, post, fu6, and fu12).\n\n:::\n\n\n::: {.cell exercise='ex_2' check='true'}\n```{webr}\n#| label: ex-2-gradethis\n#| exercise: ex_2\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n# Filtering rows with `filter()`\n\nThe `filter()` function selects rows based on conditions.\n\n::: {#exr-filter-basic}\n## Filter based on one condition\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nFilter the data to keep only participants in the \"therapist-guided\" treatment group.\n\n\n::: {.cell exercise='ex_3'}\n```{webr}\n#| label: ex-3\n#| exercise: ex_3\n\n# Filter for one group\ndf_guided <- df_clean |>\n  filter(trt == ______)\n\n# How many participants?\nnrow(df_guided)\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_3\"}\n\nRemember that `filter()` keeps rows where a condition is TRUE.\n\nTo test if a variable equals a specific value, use the double equals operator `==` (not a single `=`, which is used for assignment).\n\nThe 'trt' variable is the treatment allocation variable coded as 'waitlist', 'self-guided', and 'therapist-guided'.\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_3\"}\n\n\n::: {.cell exercise='ex_3' solution='true'}\n```{webr}\n#| label: ex-3-solution\n#| exercise: ex_3\n#| solution: true\n\n# Filter for one group\ndf_guided <- df_clean |>\n  filter(trt == \"therapist-guided\") #<1>\n\n# How many participants?\nnrow(df_guided)\n```\n:::\n\n1. Keep only rows where treatment group equals \"therapist-guided\"\n\n:::\n\n\n::: {.cell exercise='ex_3' check='true'}\n```{webr}\n#| label: ex-3-gradethis\n#| exercise: ex_3\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n::: {#exr-filter-multiple}\n## Filter with multiple conditions\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nFilter to keep only participants who:\n\n- are in the \"therapist-guided\" group, AND\n- have baseline LSAS scores of 60 or higher\n\n\n::: {.cell exercise='ex_4'}\n```{webr}\n#| label: ex-4\n#| exercise: ex_4\n\n# Filter with multiple conditions\ndf_guided_severe <- df_clean |>\n  filter(trt == ______, lsas_screen >= ______)\n\nnrow(df_guided_severe)\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_4\"}\n\nWhen you have multiple conditions in `filter()`, separate them with commas. All conditions must be TRUE for a row to be kept (AND logic).\n\nYou need one condition for treatment group (equals \"therapist-guided\" - remember quotes for text!) and another for LSAS scores (greater than or equal to 60).\n\nUse `>=` for \"greater than or equal to\".\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_4\"}\n\n\n::: {.cell exercise='ex_4' solution='true'}\n```{webr}\n#| label: ex-4-solution\n#| exercise: ex_4\n#| solution: true\n\n# Filter with multiple conditions\ndf_guided_severe <- df_clean |>\n  filter(trt == \"therapist-guided\", lsas_screen >= 60) #<1>\n\nnrow(df_guided_severe)\n```\n:::\n\n1. Both conditions must be true (AND logic) - note quotes around text value\n\n:::\n\n\n::: {.cell exercise='ex_4' check='true'}\n```{webr}\n#| label: ex-4-gradethis\n#| exercise: ex_4\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n# Creating new variables with `mutate()`\n\nThe `mutate()` function creates new columns or modifies existing ones.\n\n::: {#exr-mutate-basic}\n## Calculate change scores\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nCreate a new variable called `lsas_change` that represents the change in LSAS scores from baseline to post-treatment (post - baseline).\n\n\n::: {.cell exercise='ex_5'}\n```{webr}\n#| label: ex-5\n#| exercise: ex_5\n\n# Create change score\ndf_with_change <- df_clean |>\n  select(id, trt, lsas_screen, lsas_post) |>\n  mutate(\n    lsas_change = ______ - ______\n  )\n\nhead(df_with_change)\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_5\"}\n\nA change score represents the difference between two time points.\n\nThink about which measurement comes first (baseline) and which comes second (post-treatment). The change is calculated as: later measurement minus earlier measurement.\n\nThe baseline LSAS is `lsas_screen` and post-treatment is `lsas_post`.\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_5\"}\n\n\n::: {.cell exercise='ex_5' solution='true'}\n```{webr}\n#| label: ex-5-solution\n#| exercise: ex_5\n#| solution: true\n\n# Create change score\ndf_with_change <- df_clean |>\n  select(id, trt, lsas_screen, lsas_post) |>\n  mutate(\n    lsas_change = lsas_post - lsas_screen #<1>\n  )\n\nhead(df_with_change)\n```\n:::\n\n1. Subtract baseline from post-treatment to get change\n\nNegative values indicate improvement (lower anxiety at post-treatment).\n\n:::\n\n\n::: {.cell exercise='ex_5' check='true'}\n```{webr}\n#| label: ex-5-gradethis\n#| exercise: ex_5\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n::: {#exr-mutate-categorical}\n## Create categorical variables with `case_when()`\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nCreate a categorical variable for GAD-7 severity with these categories:\n\n- \"Minimal\" for scores 0-4\n- \"Mild\" for scores 5-9\n- \"Moderate\" for scores 10-14\n- \"Severe\" for scores 15 or higher\n\n\n::: {.cell exercise='ex_6'}\n```{webr}\n#| label: ex-6\n#| exercise: ex_6\n\n# Create categorical variable\ndf_with_severity <- df_clean |>\n  select(id, gad_screen) |>\n  mutate(\n    gad_severity = case_when(\n      gad_screen < 5 ~ \"______\",\n      gad_screen < 10 ~ \"______\",\n      gad_screen < 15 ~ \"______\",\n      gad_screen >= 15 ~ \"______\"\n    )\n  )\n\n# Check the categories\ntable(df_with_severity$gad_severity)\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_6\"}\n\nThe `case_when()` function evaluates conditions in order from top to bottom.\n\nThe syntax is: `condition ~ \"result\"`\n\nThink about the cutoffs: scores below 5 are \"Minimal\", scores from 5 to 9 are \"Mild\", etc.\n\nSince `case_when()` checks conditions in order, if a score is 7, it won't match `< 5` but will match `< 10`, so it becomes \"Mild\".\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_6\"}\n\n\n::: {.cell exercise='ex_6' solution='true'}\n```{webr}\n#| label: ex-6-solution\n#| exercise: ex_6\n#| solution: true\n\n# Create categorical variable\ndf_with_severity <- df_clean |>\n  select(id, gad_screen) |>\n  mutate(\n    gad_severity = case_when(\n      gad_screen < 5 ~ \"Minimal\",    #<1>\n      gad_screen < 10 ~ \"Mild\",      #<2>\n      gad_screen < 15 ~ \"Moderate\",  #<3>\n      gad_screen >= 15 ~ \"Severe\"    #<4>\n    )\n  )\n\n# Check the categories\ntable(df_with_severity$gad_severity)\n```\n:::\n\n1. Scores 0-4 = Minimal\n2. Scores 5-9 = Mild\n3. Scores 10-14 = Moderate\n4. Scores 15+ = Severe\n\n:::\n\n\n::: {.cell exercise='ex_6' check='true'}\n```{webr}\n#| label: ex-6-gradethis\n#| exercise: ex_6\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n# Working with factors\n\nFactors control the order of categorical variables in tables and plots.\n\n::: {#exr-factors-basic}\n## Create ordered factors\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nThe `trt` variable contains treatment assignments as text (\"waitlist\", \"self-guided\", \"therapist-guided\"). Create a properly ordered factor with the levels in this order: Waitlist, Self-guided, Therapist-guided.\n\n\n::: {.cell exercise='ex_7'}\n```{webr}\n#| label: ex-7\n#| exercise: ex_7\n\n# Create ordered factor\ndf_with_factor <- df_clean |>\n  select(id, trt) |>\n  mutate(\n    trt_factor = factor(\n      trt,\n      levels = c(\"______\", \"______\", \"______\")\n    )\n  )\n\n# Check the result\ntable(df_with_factor$trt_factor)\nlevels(df_with_factor$trt_factor)\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_7\"}\n\nThe `factor()` function needs:\n\n- The variable to convert (`trt`)\n- `levels`: the values in the order you want them (as character strings: \"waitlist\", \"self-guided\", \"therapist-guided\")\n\nBy default, factors are ordered alphabetically, which would put \"self-guided\" before \"therapist-guided\" and \"waitlist\" last. Specifying `levels` explicitly controls the order.\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_7\"}\n\n\n::: {.cell exercise='ex_7' solution='true'}\n```{webr}\n#| label: ex-7-solution\n#| exercise: ex_7\n#| solution: true\n\n# Create ordered factor\ndf_with_factor <- df_clean |>\n  select(id, trt) |>\n  mutate(\n    trt_factor = factor(\n      trt,\n      levels = c(\"waitlist\", \"self-guided\", \"therapist-guided\")  #<1>\n    )\n  )\n\n# Check the result\ntable(df_with_factor$trt_factor)\nlevels(df_with_factor$trt_factor)\n```\n:::\n\n1. Specify levels in the desired order (not alphabetical)\n\n:::\n\n\n::: {.cell exercise='ex_7' check='true'}\n```{webr}\n#| label: ex-7-gradethis\n#| exercise: ex_7\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n# Summarizing data with `group_by()` and `summarize()`\n\nCalculate summary statistics by groups.\n\n::: {#exr-summarize-basic}\n## Calculate grouped statistics\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nCalculate the mean and standard deviation of baseline LSAS scores by treatment group.\n\n\n::: {.cell exercise='ex_8'}\n```{webr}\n#| label: ex-8\n#| exercise: ex_8\n\n# Group and summarize\ngroup_stats <- df_clean |>\n  group_by(______) |>\n  summarize(\n    n = n(),\n    mean_lsas = mean(______, na.rm = TRUE),\n    sd_lsas = sd(______, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\ngroup_stats\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_8\"}\n\nThe workflow is:\n\n1. Use `group_by()` to specify which variable defines the groups\n2. Use `summarize()` to calculate statistics for each group\n\nInside `summarize()`:\n\n- `n()` counts the number of observations\n- `mean()` and `sd()` need the variable name and `na.rm = TRUE` to handle missing values\n\nWhich variable represents the baseline LSAS score?\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_8\"}\n\n\n::: {.cell exercise='ex_8' solution='true'}\n```{webr}\n#| label: ex-8-solution\n#| exercise: ex_8\n#| solution: true\n\n# Group and summarize\ngroup_stats <- df_clean |>\n  group_by(trt) |>  #<1>\n  summarize(\n    n = n(),  #<2>\n    mean_lsas = mean(lsas_screen, na.rm = TRUE),  #<3>\n    sd_lsas = sd(lsas_screen, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n\ngroup_stats\n```\n:::\n\n1. Group by treatment assignment\n2. Count participants in each treatment group\n3. Calculate mean and SD for each treatment group\n\n:::\n\n\n::: {.cell exercise='ex_8' check='true'}\n```{webr}\n#| label: ex-8-gradethis\n#| exercise: ex_8\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n::: {#exr-summarize-by}\n## Use the `.by` syntax\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nCalculate the same statistics using the `.by` argument instead of `group_by()`.\n\n\n::: {.cell exercise='ex_9'}\n```{webr}\n#| label: ex-9\n#| exercise: ex_9\n\n# Summarize with .by\ngroup_stats_by <- df_clean |>\n  summarize(\n    n = n(),\n    mean_lsas = mean(lsas_screen, na.rm = TRUE),\n    sd_lsas = sd(lsas_screen, na.rm = TRUE),\n    .by = ______\n  )\n\ngroup_stats_by\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_9\"}\n\nThe `.by` argument is an alternative to `group_by()` that goes directly inside `summarize()`.\n\nInstead of piping to `group_by()` first, you can specify `.by = ` as one of the arguments to `summarize()`.\n\nThe value for `.by` is the name of the grouping variable (without quotes).\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_9\"}\n\n\n::: {.cell exercise='ex_9' solution='true'}\n```{webr}\n#| label: ex-9-solution\n#| exercise: ex_9\n#| solution: true\n\n# Summarize with .by\ngroup_stats_by <- df_clean |>\n  summarize(\n    n = n(),\n    mean_lsas = mean(lsas_screen, na.rm = TRUE),\n    sd_lsas = sd(lsas_screen, na.rm = TRUE),\n    .by = trt  #<1>\n  )\n\ngroup_stats_by\n```\n:::\n\n1. `.by` is a cleaner alternative to `group_by()` for simple grouping by treatment\n\n:::\n\n\n::: {.cell exercise='ex_9' check='true'}\n```{webr}\n#| label: ex-9-gradethis\n#| exercise: ex_9\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n# Reshaping data: Wide to Long format\n\nConvert data from wide format (one row per participant) to long format (one row per measurement).\n\n::: {#exr-pivot-longer}\n## Convert to long format with `pivot_longer()`\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nConvert the LSAS measurements to long format. Select columns that start with \"lsas\", then pivot them longer with:\n\n- Column names going to \"time_point\"\n- Values going to \"lsas_score\"\n\n\n::: {.cell exercise='ex_10'}\n```{webr}\n#| label: ex-10\n#| exercise: ex_10\n\n# Pivot to long format\ndf_lsas_long <- df_clean |>\n  select(id, trt, starts_with(\"lsas\")) |>\n  pivot_longer(\n    cols = starts_with(\"______\"),\n    names_to = \"______\",\n    values_to = \"______\"\n  )\n\n# Check the result\nhead(df_lsas_long, 12)\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_10\"}\n\nThe `pivot_longer()` function needs three key arguments:\n\n- `cols`: Which columns to pivot (use a helper function)\n- `names_to`: What to call the new column that will contain the old column names (as a string)\n- `values_to`: What to call the new column that will contain the values (as a string)\n\nThe column names should be descriptive - what information is in the old column names? What are the values measuring?\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_10\"}\n\n\n::: {.cell exercise='ex_10' solution='true'}\n```{webr}\n#| label: ex-10-solution\n#| exercise: ex_10\n#| solution: true\n\n# Pivot to long format\ndf_lsas_long <- df_clean |>\n  select(id, trt, starts_with(\"lsas\")) |>  #<1>\n  pivot_longer(\n    cols = starts_with(\"lsas\"),  #<2>\n    names_to = \"time_point\",     #<3>\n    values_to = \"lsas_score\"     #<4>\n  )\n\n# Check the result\nhead(df_lsas_long, 12)\n```\n:::\n\n1. Select ID, treatment, and all LSAS columns\n2. Pivot all columns starting with \"lsas\"\n3. Old column names go to this new column\n4. Values go to this new column\n\nEach participant now has multiple rows, one for each time point.\n\n:::\n\n\n::: {.cell exercise='ex_10' check='true'}\n```{webr}\n#| label: ex-10-gradethis\n#| exercise: ex_10\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n::: {#exr-clean-long}\n## Clean the long format data\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nThe `time_point` column has values like \"lsas_screen\", \"lsas_post\", etc. Use `separate()` to split this into two columns: \"measure\" and \"time\".\n\n\n::: {.cell exercise='ex_11'}\n```{webr}\n#| label: ex-11\n#| exercise: ex_11\n\n# Clean time variable\ndf_lsas_long <- df_clean |>\n  select(id, trt, starts_with(\"lsas\")) |>\n  pivot_longer(\n    cols = starts_with(\"lsas\"),\n    names_to = \"time_point\",\n    values_to = \"lsas_score\"\n  ) |>\n  separate(\n    ______,\n    into = c(\"______\", \"______\"),\n    sep = \"______\"\n  )\n\nhead(df_lsas_long)\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_11\"}\n\nThe `separate()` function splits one column into multiple columns.\n\nLook at the values in `time_point`: they're formatted like \"lsas_screen\", \"lsas_post\", etc.\n\nWhat character separates the two pieces of information? That's your separator.\n\nYou need to specify:\n\n- Which column to separate\n- Names for the new columns (in `c()`)\n- What separator character to split on (as a string)\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_11\"}\n\n\n::: {.cell exercise='ex_11' solution='true'}\n```{webr}\n#| label: ex-11-solution\n#| exercise: ex_11\n#| solution: true\n\n# Clean time variable\ndf_lsas_long <- df_clean |>\n  select(id, trt, starts_with(\"lsas\")) |>  #<1>\n  pivot_longer(\n    cols = starts_with(\"lsas\"),\n    names_to = \"time_point\",\n    values_to = \"lsas_score\"\n  ) |>\n  separate(\n    time_point,              #<2>\n    into = c(\"measure\", \"time\"),  #<3>\n    sep = \"_\"                #<4>\n  )\n\nhead(df_lsas_long)\n```\n:::\n\n1. Select ID, treatment, and LSAS columns\n2. Column to separate\n3. Names for the new columns\n4. Separator character (underscore)\n\nNow we have \"measure\" (always \"lsas\") and \"time\" (screen, post, etc.) as separate columns.\n\n:::\n\n\n::: {.cell exercise='ex_11' check='true'}\n```{webr}\n#| label: ex-11-gradethis\n#| exercise: ex_11\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n# Reshaping data: Long to Wide format\n\nConvert summary data from long to wide format.\n\n::: {#exr-pivot-wider}\n## Convert to wide format with `pivot_wider()`\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nFirst, calculate mean LSAS scores by group and time. Then convert to wide format with groups as columns.\n\n\n::: {.cell exercise='ex_12'}\n```{webr}\n#| label: ex-12\n#| exercise: ex_12\n\n# Prepare long data with clean time labels\ndf_lsas_long <- df_clean |>\n  select(id, trt, lsas_screen, lsas_post) |>\n  pivot_longer(\n    cols = starts_with(\"lsas\"),\n    names_to = \"time_point\",\n    values_to = \"lsas_score\"\n  ) |>\n  separate(\n    time_point, \n    into = c(\"measure\", \"time\"), \n    sep = \"_\"\n  ) |>\n  mutate(\n    trt_factor = factor(\n      trt, \n      levels = c(\"waitlist\", \"self-guided\", \"therapist-guided\")\n    )\n  )\n\n# Summarize\nlsas_summary <- df_lsas_long |>\n  summarize(\n    mean_lsas = mean(lsas_score, na.rm = TRUE),\n    .by = c(trt_factor, time)\n  )\n\n# Pivot wider\nlsas_wide <- lsas_summary |>\n  pivot_wider(\n    names_from = ______,\n    values_from = ______\n  )\n\nlsas_wide\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_12\"}\n\n`pivot_wider()` is the opposite of `pivot_longer()` - it spreads data across columns.\n\nYou need to tell it:\n\n- `names_from`: Which column contains the values that will become new column names?\n- `values_from`: Which column contains the values to fill those new columns?\n\nThink about what you want as columns in the wide format. The problem says \"groups as columns\" - which variable contains the treatment labels?\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_12\"}\n\n\n::: {.cell exercise='ex_12' solution='true'}\n```{webr}\n#| label: ex-12-solution\n#| exercise: ex_12\n#| solution: true\n\n# Prepare long data with clean time labels\ndf_lsas_long <- df_clean |>\n  select(id, trt, lsas_screen, lsas_post) |>  #<1>\n  pivot_longer(\n    cols = starts_with(\"lsas\"),\n    names_to = \"time_point\",\n    values_to = \"lsas_score\"\n  ) |>\n  separate(\n    time_point, \n    into = c(\"measure\", \"time\"), \n    sep = \"_\"\n  ) |>\n  mutate(\n    trt_factor = factor(\n      trt, \n      levels = c(\"waitlist\", \"self-guided\", \"therapist-guided\")\n    )\n  )\n\n# Summarize\nlsas_summary <- df_lsas_long |>\n  summarize(\n    mean_lsas = mean(lsas_score, na.rm = TRUE),\n    .by = c(trt_factor, time)\n  )\n\n# Pivot wider\nlsas_wide <- lsas_summary |>\n  pivot_wider(\n    names_from = trt_factor,  #<2>\n    values_from = mean_lsas    #<3>\n  )\n\nlsas_wide\n```\n:::\n\n1. Select ID, treatment, and LSAS baseline and post\n2. Column to spread into new column names\n3. Column with values to fill the new columns\n\nNow we have a table with time points as rows and treatment groups as columns.\n\n:::\n\n\n::: {.cell exercise='ex_12' check='true'}\n```{webr}\n#| label: ex-12-gradethis\n#| exercise: ex_12\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n# Calculate remission proportions by treatment group\n\nUse filtering, mutating, and summarizing to calculate proportions by group.\n\n::: {#exr-comprehensive}\n## Remission proportions by treatment group\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nChain multiple data manipulation steps to:\n\n1. Selects id, trt, and post-treatment LSAS score\n2. Creates a binary variable indicating remission (LSAS < 30)\n3. Calculates the percentage in remission by treatment group\n\n\n::: {.cell exercise='ex_13'}\n```{webr}\n#| label: ex-13\n#| exercise: ex_13\n\n# Complete pipeline\nremission_desc <- df_clean |>\n  # Select relevant columns\n  select(______, ______, ______) |>\n  # Create remission indicator\n  mutate(\n    remission = lsas_post < ______\n  ) |>\n  # Calculate percentage by treatment group\n  summarize(\n    n = n(),\n    n_remission = sum(______, na.rm = TRUE),\n    pct_remission = (n_remission / n) * 100,\n    .by = ______\n  )\n\nremission_desc\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_13\"}\n\nWork through this step-by-step:\n\n1. **Select**: You need participant ID, treatment assignment (trt), and post-treatment LSAS\n2. **Mutate**: Create a logical variable - is LSAS post-treatment less than 30?\n3. **Summarize**: \n   - Count total participants with `n()`\n   - Count those in remission by summing the TRUE/FALSE variable (TRUE = 1, FALSE = 0)\n   - Calculate percentage: (count in remission / total count) × 100\n   - Group by treatment assignment (trt)\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_13\"}\n\n\n::: {.cell exercise='ex_13' solution='true'}\n```{webr}\n#| label: ex-13-solution\n#| exercise: ex_13\n#| solution: true\n\n# Complete pipeline\nremission_desc <- df_clean |>\n  # Select relevant columns\n  select(id, trt, lsas_post) |>  #<1>\n  # Create remission indicator\n  mutate(\n    remission = lsas_post < 30  #<2>\n  ) |>\n  # Calculate percentage by treatment group\n  summarize(\n    n = n(),\n    n_remission = sum(remission, na.rm = TRUE),  #<3>\n    pct_remission = (n_remission / n) * 100,\n    .by = trt\n  )\n\nremission_desc\n```\n:::\n\n1. Select only needed variables (ID, treatment assignment, post-treatment LSAS)\n2. Create binary variable: TRUE if LSAS < 30 (remission)\n3. Count and calculate percentage in remission by treatment group\n\nThis pipeline shows how to combine selecting variables, creating new variables, and summarizing in a single workflow. LSAS scores below 30 indicate remission from social anxiety. You'll see results for all three treatment groups.\n\n:::\n\n\n::: {.cell exercise='ex_13' check='true'}\n```{webr}\n#| label: ex-13-gradethis\n#| exercise: ex_13\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n# Calculate and visualize missing data patterns\n\nExploring missing data patterns is an important part of data analysis. Let's calculate and visualize missingness across time points.\n\n::: {#exr-missing-data}\n## Missing LSAS observations by time and group\n:::\n\n:::: {.panel-tabset}\n\n## Problem\n\nCalculate the percentage of missing LSAS observations at each time point for each treatment group, then create a line plot to visualize the pattern.\n\nSteps:\n\n1. Convert LSAS data to long format (all columns starting with \"lsas\")\n2. Separate the time variable\n3. Create clean time labels and factor variable for plotting\n4. Filter out waitlist group at follow-up time points (not measured)\n5. Create a binary variable indicating if the observation is missing\n6. Calculate the percentage missing by time and group\n7. Plot the results using the ordered time factor\n\n\n::: {.cell exercise='ex_14'}\n```{webr}\n#| label: ex-14\n#| exercise: ex_14\n\n# Convert to long format and create time variables\ndf_lsas_missing <- df_clean |>\n  select(id, trt, starts_with(\"______\")) |>\n  pivot_longer(\n    cols = starts_with(\"______\"),\n    names_to = \"______\",\n    values_to = \"______\"\n  ) |>\n  separate(______, into = c(\"measure\", \"time\"), sep = \"_\") |>\n  mutate(\n    time_clean = case_when(\n      time == \"screen\" ~ \"Baseline\",\n      time == \"v1\" ~ \"Week 1\",\n      time == \"v2\" ~ \"Week 2\",\n      time == \"v3\" ~ \"Week 3\",\n      time == \"v4\" ~ \"Week 4\",\n      time == \"v5\" ~ \"Week 5\",\n      time == \"v6\" ~ \"Week 6\",\n      time == \"v7\" ~ \"Week 7\",\n      time == \"v8\" ~ \"Week 8\",\n      time == \"post\" ~ \"Post-treatment\",\n      time == \"fu6\" ~ \"6-month follow-up\",\n      time == \"fu12\" ~ \"12-month follow-up\"\n    ),\n    time_factor = factor(\n      time_clean,\n      levels = c(\n        \"Baseline\", \"Week 1\", \"Week 2\", \"Week 3\", \"Week 4\",\n        \"Week 5\", \"Week 6\", \"Week 7\", \"Week 8\",\n        \"Post-treatment\", \"6-month follow-up\", \"12-month follow-up\"\n      )\n    )\n  ) |>\n  select(-measure) |>\n  # Filter out waitlist at follow-up (not measured)\n  filter(!(trt == \"______\" & time %in% c(\"______\", \"______\")))\n\n# Calculate missing percentages\nmissing <- df_lsas_missing |>\n  mutate(\n    is_missing = is.na(______)\n  ) |>\n  summarize(\n    n = n(),\n    n_missing = sum(______),\n    missing_percent = (______ / ______) * 100,\n    .by = c(______, ______)\n  )\n\n# Plot\nlibrary(ggplot2)\nggplot(\n  missing,\n  aes(\n    ______,\n    missing_percent,\n    group = trt,\n    color = trt\n  )\n) +\n  geom_line() +\n  geom_point() +\n  labs(\n    title = \"LSAS Percent missing observations\",\n    x = \"Time\",\n    y = \"Missing (%)\",\n    color = \"Treatment\"\n  ) +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n:::\n\n\n## Hints \n\n::: {.hint exercise=\"ex_14\"}\n\nBreaking this down:\n\n1. **Long format**: Similar to Exercise 10 - select LSAS columns and pivot them longer\n2. **Separate**: Use `separate()` on the time_point column (like Exercise 11)\n3. **Create time variables**: The `case_when()` and `factor()` code is provided - it creates readable time labels and an ordered factor\n4. **Filter**: Exclude waitlist at fu6 and fu12 time points - they weren't measured then. Use `!(condition)` for NOT, and `%in%` to check if time is in a vector of values. What's the waitlist value in the `trt` variable?\n5. **Missing indicator**: Use `is.na()` to test if a value is missing. This returns TRUE/FALSE\n6. **Summarize**: \n   - Count missing with `sum(is_missing)` (TRUE = 1, FALSE = 0)\n   - Calculate percentage: (n_missing / n) × 100\n   - Group by both treatment and time (use `trt` and `time_factor`)\n7. **Plot**: Use `time_factor` for the x-axis to get proper chronological ordering with readable labels\n\nWhich variable contains the LSAS scores? That's what you check for missingness.\n\n:::\n\n## Solution\n\n::: {.solution exercise=\"ex_14\"}\n\n\n::: {.cell exercise='ex_14' solution='true'}\n```{webr}\n#| label: ex-14-solution\n#| exercise: ex_14\n#| solution: true\n\n# Convert to long format and create time variables\ndf_lsas_missing <- df_clean |>\n  select(id, trt, starts_with(\"lsas\")) |>  #<1>\n  pivot_longer(\n    cols = starts_with(\"lsas\"),\n    names_to = \"time_point\",\n    values_to = \"lsas_score\"\n  ) |>\n  separate(time_point, into = c(\"measure\", \"time\"), sep = \"_\") |>  #<2>\n  mutate(\n    time_clean = case_when(\n      time == \"screen\" ~ \"Baseline\",\n      time == \"v1\" ~ \"Week 1\",\n      time == \"v2\" ~ \"Week 2\",\n      time == \"v3\" ~ \"Week 3\",\n      time == \"v4\" ~ \"Week 4\",\n      time == \"v5\" ~ \"Week 5\",\n      time == \"v6\" ~ \"Week 6\",\n      time == \"v7\" ~ \"Week 7\",\n      time == \"v8\" ~ \"Week 8\",\n      time == \"post\" ~ \"Post-treatment\",\n      time == \"fu6\" ~ \"6-month follow-up\",\n      time == \"fu12\" ~ \"12-month follow-up\"\n    ),\n    time_factor = factor(  #<3>\n      time_clean,\n      levels = c(\n        \"Baseline\", \"Week 1\", \"Week 2\", \"Week 3\", \"Week 4\",\n        \"Week 5\", \"Week 6\", \"Week 7\", \"Week 8\",\n        \"Post-treatment\", \"6-month follow-up\", \"12-month follow-up\"\n      )\n    )\n  ) |>\n  select(-measure) |>\n  # Filter out waitlist at follow-up (not measured)\n  filter(!(trt == \"waitlist\" & time %in% c(\"fu6\", \"fu12\")))  #<4>\n\n# Calculate missing percentages\nmissing <- df_lsas_missing |>\n  mutate(\n    is_missing = is.na(lsas_score)  #<5>\n  ) |>\n  summarize(\n    n = n(),\n    n_missing = sum(is_missing),  #<6>\n    missing_percent = (n_missing / n) * 100,  #<7>\n    .by = c(trt, time_factor)  #<8>\n  )\n\n# Plot\nlibrary(ggplot2)\nggplot(\n  missing,\n  aes(\n    time_factor,  #<9>\n    missing_percent,\n    group = trt,\n    color = trt\n  )\n) +\n  geom_line() +\n  geom_point() +\n  labs(\n    title = \"LSAS Percent missing observations\",\n    x = \"Time\",\n    y = \"Missing (%)\",\n    color = \"Treatment\"\n  ) +\n  theme_minimal() +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n:::\n\n1. Select ID, treatment assignment, and LSAS columns\n2. Separate the time_point column to extract time\n3. Create ordered factor for proper chronological plotting with readable labels\n4. Exclude waitlist at 6 and 12 month follow-ups (not measured)\n5. Create indicator: TRUE if missing, FALSE if present\n6. Sum the TRUE/FALSE values to count missing\n7. Calculate percentage missing\n8. Group by both treatment assignment and time factor\n9. Use time_factor for x-axis to ensure proper time ordering with readable labels\n\nThe plot reveals missing data patterns across time and treatment groups, which is important for understanding dropout patterns.\n\n:::\n\n\n::: {.cell exercise='ex_14' check='true'}\n```{webr}\n#| label: ex-14-gradethis\n#| exercise: ex_14\n#| check: true\ngradethis::grade_this_code()\n```\n:::\n\n\n::::\n\n# Summary\n\nIn this lab, you practiced:\n\n1. **Selecting columns** with `select()` and helper functions\n2. **Filtering rows** with `filter()` and multiple conditions\n3. **Creating variables** with `mutate()` and `case_when()`\n4. **Working with factors** to control categorical variable ordering\n5. **Summarizing data** with `group_by()` and `summarize()`\n6. **Reshaping data** with `pivot_longer()` and `pivot_wider()`\n7. **Calculating proportions** including missing data patterns\n8. **Visualizing patterns** with ggplot2\n",
    "supporting": [
      "lab-tidy-data-manipulation_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}