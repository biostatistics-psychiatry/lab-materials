---
title: "Tidy Data Manipulation"
---

In this lab, we will learn how to manipulate and reshape data using the *tidyverse* suite of packages. Data manipulation is a crucial skill in biostatistics because raw data is rarely in the format we need for analysis or visualization.

For this lab, we will continue working with the STePS dataset that we cleaned in [Import and clean data](import-clean.qmd) and explored in [Descriptive statistics](descriptive-statistics.qmd). By the end of this lab, you will be able to:

- Filter rows and select columns based on specific criteria
- Create new variables using existing data
- Group data and calculate summary statistics
- Reshape data between wide and long formats
- Understand when to use each data manipulation technique

::: callout-note
## Why data manipulation matters

We often need to:

- Calculate change scores from baseline to follow-up
- Create treatment group comparisons
- Reshape data for different types of analyses
- Combine data from multiple sources

Data wrangling can often be the most time-consuming part of a project, so it's important to be efficient and avoid errors.
:::

# Load packages and data

We'll use the same packages as before.

```{r}
#| label: load-packages
#| message: false

library(tidyverse)
library(here)
```

Let's load our cleaned data from the [Import and clean data](import-clean.qmd) lab:

```{r}
#| label: load-data
#| message: false

df_data <- read_csv(here("data", "steps_clean.csv"))

# Quick check of our data
glimpse(df_data)
```

# Basic data operations

Before we dive into complex data cleaning, let's start with the fundamental operations of data manipulation.

## Selecting columns with `select()`

The `select()` function allows us to choose which columns (variables) we want to keep in our dataset. This is useful when working with large datasets where you only need a few variables.

```{r}
#| label: select-basic

# Select just ID, group, and baseline LSAS
df_basic <- df_data |>
  select(id, group, lsas_screen)

head(df_basic)
```

We can also use helper functions to select multiple columns at once:

```{r}
#| label: select-helpers

# Select all columns that start with "lsas"
df_lsas_all <- df_data |>
  select(id, group, starts_with("lsas"))

# Check how many columns we have
ncol(df_lsas_all)
names(df_lsas_all)
```

::: {#exr-select-columns .callout-caution collapse="true"}
## Practice selecting columns

Select only the ID, group, and all PHQ-9 variables (columns starting with "phq9") from the dataset. How many columns does your new dataset have?
:::

## Filtering rows with `filter()`

The `filter()` function allows us to select specific rows based on conditions. This is useful for creating subgroups or excluding certain participants.

```{r}
#| label: filter-basic

# Keep only participants in the guided treatment group (group == 2)
df_guided <- df_data |>
  filter(group == 2)

nrow(df_guided)
```

We can use multiple conditions:

```{r}
#| label: filter-multiple

# Keep participants in guided treatment with baseline LSAS >= 60
df_guided_severe <- df_data |>
  filter(group == 2, lsas_screen >= 60)

nrow(df_guided_severe)
```

::: callout-tip
## Common filter conditions

- `==` : equal to
- `!=` : not equal to  
- `>`, `>=` : greater than (or equal)
- `<`, `<=` : less than (or equal)
- `%in%` : is in a list of values
- `is.na()` : is missing
- `!is.na()` : is not missing
:::

::: {#exr-filter-data .callout-caution collapse="true"}
## Practice filtering data

1. Filter the data to include only participants with baseline LSAS scores between 50 and 80.
2. Filter to include only participants in groups 1 or 2 (exclude waitlist).
3. How many participants meet both criteria?
:::

## Arranging rows with `arrange()`

The `arrange()` function sorts your data by one or more variables. This can be helpful for identifying extreme values or organizing data for presentation.

```{r}
#| label: arrange-basic

# Sort by baseline LSAS score (lowest to highest)
df_sorted <- df_data |>
  select(id, group, lsas_screen) |>
  arrange(lsas_screen)

head(df_sorted)
```

Use `desc()` for descending order:

```{r}
#| label: arrange-desc

# Sort by baseline LSAS score (highest to lowest)
df_sorted_desc <- df_data |>
  select(id, group, lsas_screen) |>
  arrange(desc(lsas_screen))

head(df_sorted_desc)
```

# Creating new variables with `mutate()`

The `mutate()` function allows us to create new variables or modify existing ones. This is often used for creating derived variables, such as change scores or standardized scores.

## Basic calculations

```{r}
#| label: mutate-basic

df_with_change <- df_data |>
  select(id, group, lsas_screen, lsas_post) |>
  mutate(
    # Calculate change score (post - baseline)
    lsas_change = lsas_post - lsas_screen,
    # Calculate percentage change
    lsas_pct_change = (lsas_change / lsas_screen) * 100
  )

head(df_with_change)
```

## Creating categorical variables

We often need to create categorical versions of continuous variables:

```{r}
#| label: mutate-categorical

df_with_categories <- df_data |>
  select(id, group, phq9_screen, gad_screen) |>
  mutate(
    # Using case_when() for PHQ9 severity categories
    phq9_severity = case_when(
      phq9_screen < 5 ~ "Minimal",
      phq9_screen < 10 ~ "Mild",
      phq9_screen < 15 ~ "Moderate",
      phq9_screen < 20 ~ "Moderately severe",
      phq9_screen >= 20 ~ "Severe",
      is.na(phq9_screen) ~ "Missing"
    ),
    # Convert to factor
    phq9_severity = factor(
      phq9_severity,
      levels = c(
        "Minimal",
        "Mild",
        "Moderate",
        "Moderately severe",
        "Severe",
        "Missing"
      ),
      ordered = TRUE
    ),
    # Create binary variable for high anxiety
    high_anxiety = factor(
      ifelse(gad_screen >= 10, "High", "Low"),
      levels = c("Low", "High")
    ),
    # Create more readable group labels
    group_label = factor(group,
      levels = c(0, 1, 2),
      labels = c("Waitlist", "Self-guided", "Therapist-guided")
    )
  )

# Check our new variables
table(df_with_categories$phq9_severity)
table(df_with_categories$group_label)
```

We can check how our created PHQ9 categories map to the raw scores:

```{r}
#| label: check-phq9-categories

df_with_categories |>
  select(phq9_screen, phq9_severity) |>
  distinct(phq9_screen, phq9_severity) |>
  arrange(phq9_screen)
```

::: {#exr-create-variables .callout-caution collapse="true"}
## Create new variables

1. Create a new variable called `gad_severity` that categorizes GAD-7 scores as:
   - "Minimal" (0-4)
   - "Mild" (5-9) 
   - "Moderate" (10-14)
   - "Severe" (15+)

2. Create a binary variable indicating whether someone has both high anxiety (GAD-7 ≥ 10) AND moderate-to-severe depression (PHQ-9 ≥ 10).
:::

# Summarizing data with `group_by()` and `summarize()`

A very common task is grouping data and calculating summary statistics.

## Basic summarization
We can use the `summarize()` (from `dplyr`) function to calculate summary statistics for our data.

```{r}
#| label: summarize-basic

# Calculate overall statistics
df_data |>
  summarize(
    n_participants = n(),
    mean_lsas = mean(lsas_screen, na.rm = TRUE),
    sd_lsas = sd(lsas_screen, na.rm = TRUE),
    median_lsas = median(lsas_screen, na.rm = TRUE)
  )
```

## Grouped summarization

More often, we want to calculate statistics by groups:

```{r}
#| label: summarize-grouped

# Calculate statistics by treatment group
group_stats <- df_data |>
  group_by(group) |>
  summarize(
    n_participants = n(),
    mean_lsas = mean(lsas_screen, na.rm = TRUE),
    sd_lsas = sd(lsas_screen, na.rm = TRUE),
    median_lsas = median(lsas_screen, na.rm = TRUE),
    .groups = "drop" # This removes the grouping
  )

group_stats
```

We can also use the `.by` syntax which is often cleaner:

```{r}
#| label: summarize-by

df_data |>
  summarize(
    n_participants = n(),
    mean_lsas = mean(lsas_screen, na.rm = TRUE),
    sd_lsas = sd(lsas_screen, na.rm = TRUE),
    .by = group
  )
```

::: {#exr-summarize-data .callout-caution collapse="true"}
## Practice summarizing data

1. Calculate the mean and standard deviation of GAD-7 scores by treatment group.
2. Calculate the number of participants and percentage with high anxiety (GAD-7 ≥ 10) by treatment group.
:::

# Reshaping data: Wide vs. Long format

Understanding data shapes is crucial for analysis and visualization. Let's explore the difference between wide and long format data.

## Understanding wide vs. long format
Our data is currently in wide format, where each participant has one row, with repeated measures in separate columns.

- **Wide format**: Each participant has one row, with repeated measures in separate columns  
- **Long format**: Each measurement has its own row, with a column indicating the time point

::: callout-note
## When to use each format

- **Wide format**: Calculating change scores, some statistical tests (e.g., SEM), demographic tables
- **Long format**: Plotting over time, mixed-effects models, most `ggplot` visualizations
:::

## Converting to long format with `pivot_longer()`

Let's focus on the LSAS measurements across time. First, let's see what LSAS columns we have:

```{r}
#| label: check-lsas-columns

# Check what LSAS columns we have
df_data |>
  select(starts_with("lsas")) |>
  names()

```

All of the columns that start with "lsas" are LSAS scores at different time points. Now let's convert to long format:

```{r}
#| label: pivot-longer-basic

df_lsas_long <- df_data |>
  select(id, group, starts_with("lsas")) |>
  pivot_longer(
    cols = starts_with("lsas"), # Which columns to pivot
    names_to = "time_point", # Name for the new column with time info
    values_to = "lsas_score" # Name for the new column with values
  )

head(df_lsas_long, 12)
```

## Cleaning the time variable

The time variable is not very readable. Let's clean it up and create properly ordered factors:

```{r}
#| label: clean-time-variable

df_lsas_long <- df_lsas_long |>
  # Split the time_point column to separate "lsas" from the actual time
  separate(time_point, into = c("measure", "time"), sep = "_") |>
  # Create a cleaner time variable
  mutate(
    time_clean = case_when(
      time == "screen" ~ "Baseline",
      time == "v1" ~ "Week 1",
      time == "v2" ~ "Week 2",
      time == "v3" ~ "Week 3",
      time == "v4" ~ "Week 4",
      time == "v5" ~ "Week 5",
      time == "v6" ~ "Week 6",
      time == "v7" ~ "Week 7",
      time == "v8" ~ "Week 8",
      time == "post" ~ "Post-treatment",
      time == "fu6" ~ "6-month follow-up",
      time == "fu12" ~ "12-month follow-up"
    ),
    # Also create a numeric week variable for plotting
    week_num = case_when(
      time == "screen" ~ 0,
      time == "v1" ~ 1,
      time == "v2" ~ 2,
      time == "v3" ~ 3,
      time == "v4" ~ 4,
      time == "v5" ~ 5,
      time == "v6" ~ 6,
      time == "v7" ~ 7,
      time == "v8" ~ 8,
      time == "post" ~ 9,
      time == "fu6" ~ 33, # 9 + 6*4 weeks
      time == "fu12" ~ 57 # 9 + 12*4 weeks
    ),
  ) |>
  # Remove the "measure" column since it's just "lsas" for all rows
  select(-measure)

head(df_lsas_long)
```

### Working with factors

You might notice that when we try to sort or plot this data, the time points don't appear in chronological order. This is because R treats them as character strings and sorts them alphabetically. We need to convert them to **factors** with a specific order.

::: callout-note
## What are factors?

Factors are R's way of handling categorical data with a specific order or set of allowed values. They're especially important in data analysis to:

- Ensuring consistent category names (no typos)
- Controlling the order of categories in tables and plots
- Proper statistical analysis of categorical variables
:::

Let's see the problem first:

```{r}
#| label: factor-problem

# Check the current order
unique(df_lsas_long$time_clean)

# See what happens when we sort
sort(unique(df_lsas_long$time_clean))
```

Now let's fix this by creating a properly ordered factor:

```{r}
#| label: create-factors

library(forcats) # Part of tidyverse, for working with factors

df_lsas_long <- df_lsas_long |>
  mutate(
    # Create a factor for time points with proper ordering
    time_factor = factor(
      time_clean,
      levels = c(
        "Baseline", "Week 1", "Week 2", "Week 3", "Week 4",
        "Week 5", "Week 6", "Week 7", "Week 8",
        "Post-treatment", "6-month follow-up", "12-month follow-up"
      )
    ),
    # Create a factor for treatment groups with meaningful labels
    group_factor = factor(
      group,
      levels = c(0, 1, 2),
      labels = c("Waitlist", "Self-guided", "Therapist-guided")
    )
  )

# Check our factors
levels(df_lsas_long$time_factor)
levels(df_lsas_long$group_factor)
```

Let's see how factors help by comparing how character vs factor variables are ordered:

```{r}
#| label: factors-in-action

# First, let's see the unique values in each format
unique(df_lsas_long$time_clean) |> sort()

levels(df_lsas_long$time_factor)

# Compare what happens when we arrange/sort the data
df_lsas_long |>
  select(time_clean, time_factor) |>
  arrange(time_clean) |>
  distinct(time_clean, time_factor) |>
  head(8)

df_lsas_long |>
  select(time_clean, time_factor) |>
  arrange(time_factor) |>
  distinct(time_clean, time_factor) |>
  head(8)
```

**Notice the difference**: 

- The character variable sorts alphabetically: "12-month follow-up" comes before "6-month follow-up" 
- The factor variable sorts logically: Baseline → Week 1 → Week 2 → ... → Post-treatment → Follow-ups

This is why factors are essential for any categorical variable where order matters!

::: callout-tip
## Useful factor functions from forcats

- `fct_relevel()`: Change the order of factor levels
- `fct_reorder()`: Reorder factor levels by another variable
- `fct_recode()`: Change factor level names
- `fct_collapse()`: Combine factor levels
- `fct_lump()`: Collapse least common levels into "Other"
:::

### Using factors in summaries

Now our factors will behave properly in summaries and plots:

```{r}
#| label: factors-summary

# Summary by time point (now in correct order!)
time_summary <- df_lsas_long |>
  summarize(
    n_obs = sum(!is.na(lsas_score)),
    mean_lsas = mean(lsas_score, na.rm = TRUE),
    .by = time_factor
  )

time_summary
```

::: {#exr-practice-factors .callout-caution collapse="true"}
## Practice with factors

1. Create a factor for LSAS severity levels with the order: "Mild", "Moderate", "Severe"
2. Create a factor for depression categories using PHQ-9 scores with proper ordering
3. Use `fct_recode()` to change "Self-guided" to "Self-guided CBT" in the group factor
4. Check that your factors appear in the correct order when you create a summary table
:::

### Why factors matter for visualization

Factors ensure that our plots display categories in the correct order:

```{r}
#| label: factors-plotting
#| warning: false

# Compare plots with and without proper factor ordering
library(ggplot2)

# Create sample data for demonstration
plot_data <- df_lsas_long |>
  summarize(
    mean_lsas = mean(lsas_score, na.rm = TRUE),
    .by = c(time_clean, time_factor, week_num, group_factor)
  )

# Plot with character variable (wrong order)
p1 <- ggplot(plot_data, aes(x = time_clean, y = mean_lsas, color = group_factor)) +
  geom_point(size = 3) +
  geom_line(aes(group = group_factor)) +
  labs(title = "Character variable (alphabetical order)", x = "Time") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

# Plot with factor variable (correct order)
p2 <- ggplot(plot_data, aes(x = time_factor, y = mean_lsas, color = group_factor)) +
  geom_point(size = 3) +
  geom_line(aes(group = group_factor)) +
  labs(title = "Factor variable (logical order)", x = "Time") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


# Display both plots
p1
p2
```

```{r}
#| label: factors-plotting-numeric-time
#| warning: false
#| fig-width: 10
#| fig-height: 5

ggplot(
  plot_data,
  aes(
    x = week_num,
    y = mean_lsas,
    color = group_factor
  )
) +
  geom_point(size = 3) +
  geom_line(aes(group = group_factor)) +
  scale_x_continuous(
    breaks = plot_data$week_num, # Use numeric positions
    labels = plot_data$time_clean # Use readable labels
  ) +
  labs(title = "Factor variable + Numeric Positions", x = "Time") +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    panel.grid.minor.x = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )


```

::: callout-important
## Key points about factors

1. **Always use factors for categorical variables** that will be used in analysis or plotting
2. **Set the levels in logical order** (not alphabetical)
3. **Use meaningful labels** instead of numeric codes
4. **Factors control the order** in tables, plots, and statistical output
5. **The `forcats` package** provides helpful functions for factor manipulation
:::

## Summarizing longitudinal data

Now that we have our data in long format, we can easily calculate means by group and time:

```{r}
#| label: summarize-longitudinal

lsas_summary <- df_lsas_long |>
  summarize(
    n_obs = sum(!is.na(lsas_score)),
    mean_lsas = mean(lsas_score, na.rm = TRUE),
    sd_lsas = sd(lsas_score, na.rm = TRUE),
    .by = c(group_factor, time_factor)
  )

lsas_summary
```

## Converting back to wide format with `pivot_wider()`

Sometimes we need to convert back to wide format, for example to create a table with means by group and time:

```{r}
#| label: pivot-wider

# Create a wide format table with groups as columns (just means)
lsas_wide_simple <- lsas_summary |>
  select(time_factor, group_factor, mean_lsas) |>
  pivot_wider(
    names_from = group_factor,
    values_from = mean_lsas,
    names_prefix = "mean_"
  )

lsas_wide_simple

# More complex example: keeping multiple statistics (mean, sd, and n)
lsas_wide_detailed <- lsas_summary |>
  pivot_wider(
    names_from = group_factor,
    values_from = c(mean_lsas, sd_lsas, n_obs),
    names_sep = "_"
  )

lsas_wide_detailed |>
  knitr::kable(digits = 2)
```

::: callout-tip
## Advanced pivot_wider: Multiple value columns

Notice how `pivot_wider()` can handle multiple value columns at once:

- `values_from = c(mean_lsas, sd_lsas, n_obs)`: Pivots all three statistics
- `names_sep = "_"`: Controls how column names are created
- Result: Each group gets three columns (e.g., `mean_lsas_Waitlist`, `sd_lsas_Waitlist`, `n_obs_Waitlist`)

This is very useful for creating comprehensive summary tables!
:::

::: {#exr-reshape-data .callout-caution collapse="true"}
## Practice reshaping data

1. Convert the GAD-7 data to long format (select columns starting with "gad").
2. Calculate the mean GAD-7 score by group and time point.
3. Create a wide format table showing GAD-7 means with time points as rows and groups as columns.
:::

::: {#exr-comprehensive-manipulation .callout-caution collapse="true"}
## Comprehensive data manipulation

Combine everything you've learned to:

1. Create a dataset with only baseline and post-treatment measurements for LSAS, GAD-7, and PHQ-9.
2. Calculate change scores for each measure.
3. Create a summary table showing mean change scores by treatment group.
4. Create categories for treatment response (e.g., "Improved" if LSAS decreased by ≥10 points).
5. Calculate the percentage of responders in each treatment group.
:::

```{r}
#| label: gt-table
# Using gt for better table formatting
library(gt)

my_table <- lsas_wide_detailed |>
  gt() |>
  tab_spanner(
    label = "Waitlist",
    columns = contains("Waitlist")
  ) |>
  tab_spanner(
    label = "Self-guided",
    columns = contains("Self-guided")
  ) |>
  tab_spanner(
    label = "Therapist-guided",
    columns = contains("Therapist-guided")
  ) |>
  cols_label(
    time_factor = "Time Point",
    mean_lsas_Waitlist = "M",
    sd_lsas_Waitlist = "SD",
    n_obs_Waitlist = "N",
    `mean_lsas_Self-guided` = "M",
    `sd_lsas_Self-guided` = "SD",
    `n_obs_Self-guided` = "N",
    `mean_lsas_Therapist-guided` = "M",
    `sd_lsas_Therapist-guided` = "SD",
    `n_obs_Therapist-guided` = "N"
  ) |>
  fmt_number(
    columns = starts_with("mean_") | starts_with("sd_"),
    decimals = 2
  ) |>
  fmt_number(
    columns = starts_with("n_obs"),
    decimals = 0
  ) |>
  sub_missing(
    columns = everything(),
    missing_text = "—"
  ) |>
  # Custom styling
  tab_options(
    table.border.top.style = "solid",
    table.border.top.width = px(2),
    table.border.bottom.style = "solid",
    table.border.bottom.width = px(2),
    table.border.left.style = "none",
    table.border.right.style = "none",
    heading.border.bottom.style = "solid",
    heading.border.bottom.width = px(1),
    column_labels.border.top.style = "solid",
    column_labels.border.top.width = px(1),
    column_labels.border.bottom.style = "solid",
    column_labels.border.bottom.width = px(1),
    table_body.border.bottom.style = "none",
    table.font.size = 12
  ) |>
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_column_spanners()
  ) |>
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_column_labels()
  ) |>
  tab_style(
    style = cell_text(align = "center"),
    locations = cells_body(columns = -time_factor)
  ) |>
  # Add table title and subtitle
  tab_header(
    title = "Table 1",
    subtitle = "LSAS Scores by Treatment Group and Time Point"
  ) |>
  # Add table note
  tab_source_note(
    source_note = "Note. LSAS = Liebowitz Social Anxiety Scale; M = Mean; SD = Standard Deviation; N = Sample Size."
  )

my_table
gtsave(my_table, "tables/my_table.docx")
```